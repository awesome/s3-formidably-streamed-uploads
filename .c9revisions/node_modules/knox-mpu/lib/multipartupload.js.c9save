{"ts":1356031137167,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"var _ = require('lodash'),\n    EventEmitter = require('events').EventEmitter,\n    Batch = require('batch'),\n    fs = require('fs'),\n    path = require('path'),\n    os = require('os'),\n    util = require('util'),\n    parse = require('./parse');\n\n/**\n * Initializes a Amazon S3 Multi part file upload with the given options\n */\nfunction MultiPartUpload(opts, callback) {\n    if (!opts.client || !opts.objectName) {\n        throw new Error('MultiPart upload must be created from a client and provide a object name');\n    }\n    \n    if (!opts.stream && !opts.file) {\n        throw new Error('MultiPart upload must be passed either a stream or file parameter');\n    }\n    \n    if (opts.stream && opts.file) {\n        throw new Error('You cannot provide both a stream and a file to upload');\n    }\n \n    this.objectName = opts.objectName;\n    this.headers = opts.headers || {};\n    this.client = opts.client;\n    this.partSize = opts.partSize || 5242880; // 5MB default\n    this.uploadId = null;\n    this.uploads = new Batch();\n    \n    if (opts.stream) {\n        this._putStream(opts.stream, callback);\n    } else {\n        this._putFile(opts.file, callback);\n    }\n    \n}\nutil.inherits(MultiPartUpload, EventEmitter);\n\n/**\n * Attempts to initiate the MultiPartUpload request (gets the upload ID)\n */\nMultiPartUpload.prototype._initiate = function(callback) {\n    // Send the initiate request\n    var req = this.client.request('POST', this.objectName + '?uploads', this.headers),\n        mpu = this;\n        \n    // Handle the xml response\n    parse.xmlResponse(req, function(err, body) {\n        \n        if (err) return callback(err);        \n        if (!body.UploadId) return callback('Invalid upload ID');\n\n        mpu.uploadId = body.UploadId;\n        mpu.emit('initiated', body.UploadId);\n        return callback(null, body.UploadId);\n    });\n\n    req.end();\n}\n\n/**\n * Streams a file to S3 using a multipart form upload\n *\n * Divides the file into separate files, and then writes them to Amazon S3\n */\nMultiPartUpload.prototype._putFile = function(file, callback) {\n    if (!file) return callback('Invalid file');\n    \n    var mpu = this;\n    \n    fs.exists(file, function(exists) {\n        if (!exists) {\n            return callback('File does not exist');\n        }\n        \n        var stream = fs.createReadStream(file);\n        mpu._putStream(stream, callback);\n    });\n}\n\n/**\n * Streams a stream to S3 using a multipart form upload.\n * \n * It will attempt to initialize the upload (if not already started), read the stream in, \n * write the stream to a temporary file of the given partSize, and then start uploading a part\n * each time a part is available\n */\nMultiPartUpload.prototype._putStream = function(stream, callback) {  \n  \n    if (!stream) return callback('Invalid stream');\n\n    var mpu = this;\n\n    if (!this.uploadId) {\n        this._initiate(function(err, uploadId) {\n            if (err || !uploadId) return callback('Unable to initiate stream upload');\n        });    \n    } \n    // Start handling the stream straight away\n    mpu._handleStream(stream, callback);\n}\n\n/**\n  Handles an incoming stream, divides it into parts, and uploads it to S3\n **/\nMultiPartUpload.prototype._handleStream = function(stream, callback) {\n\n    var mpu = this, \n        parts = [], \n        current;\n\n    // Create a new part\n    function newPart() {\n        var partId = parts.length + 1,\n            partFileName = path.resolve(path.join(os.tmpDir(), 'mpu-' + (mpu.uploadId || Date.now()) + '-' + partId)),\n            partFile = fs.createWriteStream(partFileName),\n            part = {\n                id: partId,\n                stream: partFile,\n                fileName: partFileName,\n                length: 0\n            };\n\n        parts.push(part);\n        return part;\n    }\n\n    function partReady(part) {\n        if (!part) return\n\n        // Ensure the stream is closed\n        if (part.stream.writable) {\n            part.stream.end();\n        }\n        mpu.uploads.push(mpu._uploadPart.bind(mpu, part));\n    }\n\n    // Handle the data coming in\n    stream.on('data', function(buffer) {\n        if (!current) {\n            current = newPart();\n        }\n\n        current.stream.write(buffer);\n        current.length += buffer.length;\n\n        // Check if we have a part\n        if (current.length >= mpu.partSize) {\n            partReady(current);\n            current = null;\n        }\n    });\n\n    // Handle the end of the stream\n    stream.on('end', function() {\n        if (current) {\n            partReady(current);\n        }\n        \n        // Wait for the completion of the uploads\n        return mpu._completeUploads(callback);\n    });\n\n    // Handle errors\n    stream.on('error', function(err) {\n        // Clean up\n        return callback(err);\n    });\n}\n\n/**\n  Uploads a part, or if we are not ready yet, waits for the upload to be initiated\n  and will then upload\n **/\nMultiPartUpload.prototype._uploadPart = function(part, callback) {    \n    \n    // If we haven't started the upload yet, wait for the initialization\n    if (!this.uploadId) {\n      return this.on('initiated', this._uploadPart.bind(this, part, callback));\n    }\n\n    var url = this.objectName + '?partNumber=' + part.id + '&uploadId=' + this.uploadId,\n        headers = { 'Content-Length': part.length },\n        req = this.client.request('PUT', url, headers),\n        partStream = fs.createReadStream(part.fileName),\n        mpu = this;\n\n    // Wait for the upload to complete\n    req.on('response', function(res) { \n        if (res.statusCode != 200) return callback({part: part.id, message: 'Upload failed'});\n        \n        // Grab the etag and return it\n        var etag = res.headers['etag'],\n            result = {part: part.id, etag: etag, size: part.length};\n        \n        mpu.emit('uploaded', result);\n        \n        // Remove the temporary file\n        fs.unlink(part.fileName, function(err) {\n            return callback(err, result);\n        });        \n    });\n    \n    // Handle errors\n    req.on('error', function(err) {\n        var result = {part: part.id, message: err};\n        mpu.emit('failed', result);\n        return callback(result);\n    });\n      \n    partStream.pipe(req);\n    mpu.emit('uploading', part.id);\n}\n\n/**\n  Indicates that all uploads have been started and that we should wait for completion\n **/\nMultiPartUpload.prototype._completeUploads = function(callback) {    \n    \n    var mpu = this;    \n\n    this.uploads.end(function(err, results) {\n        \n        if (err) return callback(err);\n        \n        var size = 0, parts, body;\n        parts = _.map(results, function(value) {\n            size += value.size;\n            return util.format('<Part><PartNumber>%d</PartNumber><ETag>%s</ETag></Part>', value.part, value.etag);\n        }).join('');\n        \n        var req = mpu.client.request('POST', mpu.objectName + '?uploadId=' + mpu.uploadId);\n        \n        // Register the response handler\n        parse.xmlResponse(req, function(err, body) {\n            if (err) return callback(err);        \n            delete body.$;\n            body.size = size;\n            mpu.emit('completed', body);\n            return callback(null, body);\n        });\n        \n        // Write the request\n        req.write('<CompleteMultipartUpload>' + parts + '</CompleteMultipartUpload>');\n        req.end();\n    });    \n}\n\nmodule.exports = MultiPartUpload;"]],"start1":0,"start2":0,"length1":0,"length2":7392}]],"length":7392}
