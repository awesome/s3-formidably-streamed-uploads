{"ts":1357770279213,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"\r\n/*!\r\n * knox - auth\r\n * Copyright(c) 2010 LearnBoost <dev@learnboost.com>\r\n * MIT Licensed\r\n */\r\n\r\n/**\r\n * Module dependencies.\r\n */\r\n\r\nvar crypto = require('crypto')\r\n  , parse = require('url').parse;\r\n\r\n/**\r\n * Query string params permitted in the canonicalized resource.\r\n * @see http://docs.amazonwebservices.com/AmazonS3/latest/dev/RESTAuthentication.html#ConstructingTheCanonicalizedResourceElement\r\n */\r\n\r\nvar whitelist = [\r\n    'acl'\r\n  , 'delete'\r\n  , 'lifecycle'\r\n  , 'location'\r\n  , 'logging'\r\n  , 'notification'\r\n  , 'partNumber'\r\n  , 'policy'\r\n  , 'requestPayment'\r\n  , 'torrent'\r\n  , 'uploadId'\r\n  , 'uploads'\r\n  , 'versionId'\r\n  , 'versioning'\r\n  , 'versions'\r\n  , 'website'\r\n];\r\n\r\n/**\r\n * Return an \"Authorization\" header value with the given `options`\r\n * in the form of \"AWS <key>:<signature>\"\r\n *\r\n * @param {Object} options\r\n * @return {String}\r\n * @api private\r\n */\r\n\r\nexports.authorization = function(options){\r\n  return 'AWS ' + options.key + ':' + exports.sign(options);\r\n};\r\n\r\n/**\r\n * Simple HMAC-SHA1 Wrapper\r\n *\r\n * @param {Object} options\r\n * @return {String}\r\n * @api private\r\n */\r\n\r\nexports.hmacSha1 = function(options){\r\n  return crypto.createHmac('sha1', options.secret).update(options.message).digest('base64');\r\n};\r\n\r\n/**\r\n * Create a base64 sha1 HMAC for `options`.\r\n *\r\n * @param {Object} options\r\n * @return {String}\r\n * @api private\r\n */\r\n\r\nexports.sign = function(options){\r\n  options.message = exports.stringToSign(options);\r\n  return exports.hmacSha1(options);\r\n};\r\n\r\n/**\r\n * Create a base64 sha1 HMAC for `options`.\r\n *\r\n * Specifically to be used with S3 presigned URLs\r\n *\r\n * @param {Object} options\r\n * @return {String}\r\n * @api private\r\n */\r\n\r\nexports.signQuery = function(options){\r\n  options.message = exports.queryStringToSign(options);\r\n  return exports.hmacSha1(options);\r\n};\r\n\r\n/**\r\n * Return a string for sign() with the given `options`.\r\n *\r\n * Spec:\r\n *\r\n *    <verb>\\n\r\n *    <md5>\\n\r\n *    <content-type>\\n\r\n *    <date>\\n\r\n *    [headers\\n]\r\n *    <resource>\r\n *\r\n * @param {Object} options\r\n * @return {String}\r\n * @api private\r\n */\r\n\r\nexports.stringToSign = function(options){\r\n  var headers = options.amazonHeaders || '';\r\n  if (headers) headers += '\\n';\r\n  return [\r\n      options.verb\r\n    , options.md5\r\n    , options.contentType\r\n    , options.date.toUTCString()\r\n    , headers + options.resource\r\n  ].join('\\n');\r\n};\r\n\r\n/**\r\n * Return a string for sign() with the given `options`, but is meant exclusively\r\n * for S3 presigned URLs\r\n *\r\n * Spec:\r\n *\r\n *    <date>\\n\r\n *    <resource>\r\n *\r\n * @param {Object} options\r\n * @return {String}\r\n * @api private\r\n */\r\n\r\nexports.queryStringToSign = function(options){\r\n  return 'GET\\n\\n\\n' +\r\n    options.date + '\\n' +\r\n    options.resource;\r\n};\r\n\r\n/**\r\n * Perform the following:\r\n *\r\n *  - ignore non-amazon headers\r\n *  - lowercase fields\r\n *  - sort lexicographically\r\n *  - trim whitespace between \":\"\r\n *  - join with newline\r\n *\r\n * @param {Object} headers\r\n * @return {String}\r\n * @api private\r\n */\r\n\r\nexports.canonicalizeHeaders = function(headers){\r\n  var buf = []\r\n    , fields = Object.keys(headers);\r\n  for (var i = 0, len = fields.length; i < len; ++i) {\r\n    var field = fields[i]\r\n      , val = headers[field]\r\n      , field = field.toLowerCase();\r\n    if (0 !== field.indexOf('x-amz')) continue;\r\n    buf.push(field + ':' + val);\r\n  }\r\n  return buf.sort().join('\\n');\r\n};\r\n\r\n/**\r\n * Perform the following:\r\n *\r\n *  - ignore non sub-resources\r\n *  - sort lexicographically\r\n *\r\n * @param {String} a URI-encoded resource (path + query string)\r\n * @return {String}\r\n * @api private\r\n */\r\n\r\nexports.canonicalizeResource = function(resource){\r\n  var url = parse(resource, true)\r\n    , path = url.pathname\r\n    , buf = [];\r\n\r\n  // apply the query string whitelist\r\n  Object.keys(url.query).forEach(function (key) {\r\n      if (whitelist.indexOf(key) != -1) {\r\n          buf.push(key + (url.query[key] ? \"=\" + url.query[key] : ''));\r\n      }\r\n  });\r\n\r\n  return path + (buf.length\r\n    ? '?' + buf.sort().join('&')\r\n    : '');\r\n};\r\n"]],"start1":0,"start2":0,"length1":0,"length2":4049}]],"length":4049}
