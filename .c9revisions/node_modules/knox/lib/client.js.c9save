{"ts":1357770293547,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"/*!\n * knox - Client\n * Copyright(c) 2010 LearnBoost <dev@learnboost.com>\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n */\n\nvar Emitter = require('events').EventEmitter\n  , utils = require('./utils')\n  , auth = require('./auth')\n  , http = require('http')\n  , https = require('https')\n  , url = require('url')\n  , mime = require('mime')\n  , fs = require('fs')\n  , crypto = require('crypto')\n  , xml2js = require('xml2js')\n  , qs = require('querystring');\n\n// The max for multi-object delete, bucket listings, etc.\nvar BUCKET_OPS_MAX = 1000;\n\n/**\n * Register event listeners on a request object to convert standard http\n * request events into appropriate call backs.\n * @param {Request} req The http request\n * @param {Function} fn(err, res) The callback function.\n * err - The exception if an exception occurred while sending the http\n * request (for example if internet connection was lost).\n * res - The http response if no exception occurred.\n * @api private\n */\nfunction registerReqListeners(req, fn){\n  req.on('response', function(res){ fn(null, res); });\n  req.on('error', fn);\n}\n\nfunction ensureLeadingSlash(filename) {\n  return filename[0] !== '/' ? '/' + filename : filename;\n}\n\nfunction removeLeadingSlash(filename) {\n  return filename[0] === '/' ? filename.substring(1) : filename;\n}\n\nfunction getHeader(headers, headerNameLowerCase) {\n  for (var header in headers) {\n    if (header.toLowerCase() === headerNameLowerCase) {\n      return headers[header];\n    }\n  }\n  return null;\n}\n\n/**\n * Initialize a `Client` with the given `options`.\n *\n * Required:\n *\n *  - `key`     amazon api key\n *  - `secret`  amazon secret\n *  - `bucket`  bucket name string, ex: \"learnboost\"\n *\n * @param {Object} options\n * @api public\n */\n\nvar Client = module.exports = exports = function Client(options) {\n  if (!options.key) throw new Error('aws \"key\" required');\n  if (!options.secret) throw new Error('aws \"secret\" required');\n  if (!options.bucket) throw new Error('aws \"bucket\" required');\n\n  if (options.bucket !== options.bucket.toLowerCase()) {\n    throw new Error('AWS bucket names must be all lower case. ' +\n      'See https://github.com/LearnBoost/knox/issues/44#issuecomment-7074177 ' +\n      'for details.');\n  }\n\n  var domain = 's3.amazonaws.com';\n  if (options.region) {\n    if (options.region === 'us-standard') {\n      // Pesky inconsistency\n      domain = 's3.amazonaws.com';\n    } else {\n      domain = 's3-' + options.region + '.amazonaws.com';\n    }\n  }\n  this.endpoint = options.bucket + '.' + domain;\n  this.secure = 'undefined' == typeof options.port;\n  utils.merge(this, options);\n\n  this.url = this.secure ? this.https : this.http;\n};\n\n/**\n * Request with `filename` the given `method`, and optional `headers`.\n *\n * @param {String} method\n * @param {String} filename\n * @param {Object} headers\n * @return {ClientRequest}\n * @api private\n */\n\nClient.prototype.request = function(method, filename, headers){\n  var options = { host: this.endpoint, agent: this.agent }\n    , date = new Date\n    , headers = headers || {};\n\n  if ('undefined' != typeof this.port) {\n    options.port = this.port;\n  }\n\n  filename = ensureLeadingSlash(filename);\n\n  // Default headers\n  utils.merge(headers, {\n      Date: date.toUTCString()\n    , Host: this.endpoint\n  });\n\n  if ('token' in this)\n    headers['x-amz-security-token'] = this.token;\n\n  // Authorization header\n  headers.Authorization = auth.authorization({\n      key: this.key\n    , secret: this.secret\n    , verb: method\n    , date: date\n    , resource: auth.canonicalizeResource('/' + this.bucket + filename)\n    , contentType: getHeader(headers, 'content-type')\n    , md5: getHeader(headers, 'content-md5') || ''\n    , amazonHeaders: auth.canonicalizeHeaders(headers)\n  });\n\n  // Issue request\n  options.method = method;\n  options.path = filename;\n  options.headers = headers;\n  var req = (this.secure ? https : http).request(options);\n  req.url = this.url(filename);\n\n  return req;\n};\n\n/**\n * PUT data to `filename` with optional `headers`.\n *\n * Example:\n *\n *     // Fetch the size\n *     fs.stat('Readme.md', function(err, stat){\n *      // Create our request\n *      var req = client.put('/test/Readme.md', {\n *          'Content-Length': stat.size\n *        , 'Content-Type': 'text/plain'\n *      });\n *      fs.readFile('Readme.md', function(err, buf){\n *        // Output response\n *        req.on('response', function(res){\n *          console.log(res.statusCode);\n *          console.log(res.headers);\n *          res.on('data', function(chunk){\n *            console.log(chunk.toString());\n *          });\n *        });\n *        // Send the request with the file's Buffer obj\n *        req.end(buf);\n *      });\n *     });\n *\n * @param {String} filename\n * @param {Object} headers\n * @return {ClientRequest}\n * @api public\n */\n\nClient.prototype.put = function(filename, headers){\n  headers = utils.merge({\n      Expect: '100-continue'\n  }, headers || {});\n  return this.request('PUT', filename, headers);\n};\n\n/**\n * PUT the file at `src` to `filename`, with callback `fn`\n * receiving a possible exception, and the response object.\n *\n * Example:\n *\n *    client\n *     .putFile('package.json', '/test/package.json', function(err, res){\n *       if (err) throw err;\n *       console.log(res.statusCode);\n *       console.log(res.headers);\n *     });\n *\n * @param {String} src\n * @param {String} filename\n * @param {Object|Function} headers\n * @param {Function} fn\n * @return {EventEmitter}\n * @api public\n */\n\nClient.prototype.putFile = function(src, filename, headers, fn){\n  var self = this;\n  var emitter = new Emitter;\n\n  if ('function' == typeof headers) {\n    fn = headers;\n    headers = {};\n  }\n\n  fs.stat(src, function (err, stat) {\n    if (err) return fn(err);\n\n    var contentType = mime.lookup(src);\n\n    // Add charset if it's known.\n    var charset = mime.charsets.lookup(contentType);\n    if (charset) {\n      contentType += '; charset=' + charset;\n    }\n\n    headers = utils.merge({\n        'Content-Length': stat.size\n      , 'Content-Type': contentType\n    }, headers);\n\n    var stream = fs.createReadStream(src);\n    var req = self.putStream(stream, filename, headers, fn);\n\n    req.on('progress', emitter.emit.bind(emitter, 'progress'));\n  });\n\n  return emitter;\n};\n\n/**\n * PUT the given `stream` as `filename` with `headers`.\n * `headers` must contain `'Content-Length'` at least.\n *\n * @param {Stream} stream\n * @param {String} filename\n * @param {Object} headers\n * @param {Function} fn\n * @return {ClientRequest}\n * @api public\n */\n\nClient.prototype.putStream = function(stream, filename, headers, fn){\n  var contentLength = getHeader(headers, 'content-length');\n  if (contentLength === null) {\n    process.nextTick(function () {\n      fn(new Error('You must specify a Content-Length header.'));\n    });\n    return;\n  }\n\n  var self = this;\n  var req = self.put(filename, headers);\n\n  registerReqListeners(req, fn);\n  stream.on('error', fn);\n\n  var written = 0;\n  stream.on('data', function(chunk){\n    written += chunk.length;\n    req.emit('progress', {\n        percent: written / contentLength * 100 | 0\n      , written: written\n      , total: contentLength\n    });\n  });\n\n  stream.pipe(req);\n  return req;\n};\n\n/**\n * PUT the given `buffer` as `filename` with optional `headers`.\n * Callback `fn` receives a possible exception and the response object.\n *\n * @param {Buffer} buffer\n * @param {String} filename\n * @param {Object|Function} headers\n * @param {Function} fn\n * @return {ClientRequest}\n * @api public\n */\n\nClient.prototype.putBuffer = function(buffer, filename, headers, fn){\n  if ('function' == typeof headers) {\n    fn = headers;\n    headers = {};\n  }\n\n  headers['Content-Length'] = buffer.length;\n\n  var req = this.put(filename, headers);\n  registerReqListeners(req, fn);\n  req.end(buffer);\n  return req;\n};\n\n/**\n * Copy files from `sourceFilename` to `destFilename` with optional `headers`.\n *\n * @param {String} sourceFilename\n * @param {String} destFilename\n * @param {Object} headers\n * @return {ClientRequest}\n * @api public\n */\n\nClient.prototype.copy = function(sourceFilename, destFilename, headers){\n  sourceFilename = ensureLeadingSlash(sourceFilename);\n  headers = utils.merge({\n      Expect: '100-continue'\n  }, headers || {});\n  headers['x-amz-copy-source'] = '/' + this.bucket + sourceFilename;\n  headers['Content-Length'] = 0; // to avoid Node's automatic chunking if omitted\n\n  return this.put(destFilename, headers);\n};\n\n/**\n * Copy files from `sourceFilename` to `destFilename` with optional `headers`\n * and callback `fn` with a possible exception and the response.\n *\n * @param {String} sourceFilename\n * @param {String} destFilename\n * @param {Object|Function} headers\n * @param {Function} fn\n * @api public\n */\n\nClient.prototype.copyFile = function(sourceFilename, destFilename, headers, fn){\n  if ('function' == typeof headers) {\n    fn = headers;\n    headers = {};\n  }\n\n  var req = this.copy(sourceFilename, destFilename, headers);\n  registerReqListeners(req, fn);\n  req.end();\n  return req;\n};\n\n/**\n * GET `filename` with optional `headers`.\n *\n * @param {String} filename\n * @param {Object} headers\n * @return {ClientRequest}\n * @api public\n */\n\nClient.prototype.get = function(filename, headers){\n  return this.request('GET', filename, headers);\n};\n\n/**\n * GET `filename` with optional `headers` and callback `fn`\n * with a possible exception and the response.\n *\n * @param {String} filename\n * @param {Object|Function} headers\n * @param {Function} fn\n * @api public\n */\n\nClient.prototype.getFile = function(filename, headers, fn){\n  if ('function' == typeof headers) {\n    fn = headers;\n    headers = {};\n  }\n\n  var req = this.get(filename, headers);\n  registerReqListeners(req, fn);\n  req.end();\n  return req;\n};\n\n/**\n * Issue a HEAD request on `filename` with optional `headers.\n *\n * @param {String} filename\n * @param {Object} headers\n * @return {ClientRequest}\n * @api public\n */\n\nClient.prototype.head = function(filename, headers){\n  return this.request('HEAD', filename, headers);\n};\n\n/**\n * Issue a HEAD request on `filename` with optional `headers`\n * and callback `fn` with a possible exception and the response.\n *\n * @param {String} filename\n * @param {Object|Function} headers\n * @param {Function} fn\n * @api public\n */\n\nClient.prototype.headFile = function(filename, headers, fn){\n  if ('function' == typeof headers) {\n    fn = headers;\n    headers = {};\n  }\n  var req = this.head(filename, headers);\n  registerReqListeners(req, fn);\n  req.end();\n  return req;\n};\n\n/**\n * DELETE `filename` with optional `headers.\n *\n * @param {String} filename\n * @param {Object} headers\n * @return {ClientRequest}\n * @api public\n */\n\nClient.prototype.del = function(filename, headers){\n  return this.request('DELETE', filename, headers);\n};\n\n/**\n * DELETE `filename` with optional `headers`\n * and callback `fn` with a possible exception and the response.\n *\n * @param {String} filename\n * @param {Object|Function} headers\n * @param {Function} fn\n * @api public\n */\n\nClient.prototype.deleteFile = function(filename, headers, fn){\n  if ('function' == typeof headers) {\n    fn = headers;\n    headers = {};\n  }\n  var req = this.del(filename, headers);\n  registerReqListeners(req, fn);\n  req.end();\n};\n\nfunction xmlEscape(string) {\n    return string.replace(/&/g, '&amp;')\n                 .replace(/</g, '&lt;')\n                 .replace(/>/g, '&gt;')\n                 .replace(/\"/g, '&quot;');\n}\n\nfunction makeDeleteXmlString(keys) {\n    var tags = keys.map(function(key){\n        return '<Object><Key>' +\n          xmlEscape(removeLeadingSlash(key)) +\n          '</Key></Object>';\n    });\n    return '<Delete>' + tags.join('') + '</Delete>';\n}\n\n/**\n * Delete up to 1000 files at a time, with optional `headers`\n * and callback `fn` with a possible exception and the response.\n *\n * @param {Array[String]} filenames\n * @param {Object|Function} headers\n * @param {Function} fn\n * @api public\n */\n\nClient.prototype.deleteMultiple = function(filenames, headers, fn){\n  if (filenames.length > BUCKET_OPS_MAX) {\n    throw new Error('Can only delete up to ' + BUCKET_OPS_MAX + ' files ' +\n                    'at a time. You\\'ll need to batch them.');\n  }\n\n  if ('function' == typeof headers) {\n    fn = headers;\n    headers = {};\n  }\n\n  var xml = makeDeleteXmlString(filenames);\n\n  headers['Content-Length'] = xml.length;\n  headers['Content-MD5'] = crypto.createHash('md5').update(xml).digest('base64');\n\n  return this.request('POST', '/?delete', headers)\n  .on('response', function(res){\n    fn(null, res);\n  })\n  .on('error', function(err){\n    fn(err);\n  })\n  .end(xml);\n};\n\n/**\n * Possible params for Client#list.\n *\n * @type {Object}\n */\n\nvar LIST_PARAMS = {\n    delimiter: true\n  , marker: true\n  ,'max-keys': true\n  , prefix: true\n};\n\n/**\n * Normalization map for Client#list.\n *\n * @type {Object}\n */\n\nvar RESPONSE_NORMALIZATION = {\n    MaxKeys: Number,\n    IsTruncated: Boolean,\n    LastModified: Date,\n    Size: Number,\n    Contents: Array\n};\n\n/**\n * Convert data we get from S3 xml in Client#list, since every primitive\n * value there is a string.\n *\n * @type {Object}\n */\n\nfunction normalizeResponse(data) {\n  for (var key in data) {\n    var Constr = RESPONSE_NORMALIZATION[key];\n\n    if (Constr) {\n      if (Constr === Date) {\n        data[key] = new Date(data[key]);\n      } else if (Constr === Array) {\n        // If there's only one element in the array xml2js doesn't know that\n        // it should be an array; array-ify it.\n        if (!Array.isArray(data[key])) {\n          data[key] = [data[key]];\n        }\n      } else if (Constr === Boolean) {\n        data[key] = data[key] === 'true';\n      } else {\n        data[key] = Constr(data[key]);\n      }\n    }\n\n    if (Array.isArray(data[key])) {\n        data[key].forEach(normalizeResponse);\n    }\n  }\n}\n\n/**\n * List up to 1000 objects at a time, with optional `headers`, `params`\n * and callback `fn` with a possible exception and the response.\n *\n * @param {Object|Function} params\n * @param {Object|Function} headers\n * @param {Function} fn\n * @api public\n */\n\nClient.prototype.list = function(params, headers, fn){\n  if ('function' == typeof headers) {\n    fn = headers;\n    headers = {};\n  }\n\n  if ('function' == typeof params) {\n    fn = params;\n    params = null;\n  }\n\n  if (params && !LIST_PARAMS[Object.keys(params)[0]]) {\n    headers = params;\n    params = null;\n  }\n\n  var url = params ? '?' + qs.stringify(params) : '';\n\n  this.getFile(url, headers, function(err, res){\n    if (err) return fn(err);\n\n    var xmlStr = '';\n\n    res.on('data', function(chunk){\n      xmlStr += chunk;\n    });\n\n    res.on('end', function(){\n      new xml2js.Parser({explicitArray: false, explicitRoot: false})\n        .parseString(xmlStr, function(err, data){\n          if (err) return fn(err);\n\n          delete data.$;\n          normalizeResponse(data);\n\n          if (!('Contents' in data)) {\n            data.Contents = [];\n          }\n\n          fn(null, data);\n        });\n    }).on('error', fn);\n  });\n};\n\n/**\n * Return a url to the given `filename`.\n *\n * @param {String} filename\n * @return {String}\n * @api public\n */\n\nClient.prototype.http = function(filename){\n  return 'http://' + this.endpoint + filename;\n};\n\n/**\n * Return an HTTPS url to the given `filename`.\n *\n * @param {String} filename\n * @return {String}\n * @api public\n */\n\nClient.prototype.https = function(filename){\n  return 'https://' + this.endpoint + filename;\n};\n\n/**\n * Return an S3 presigned url to the given `filename`.\n *\n * @param {String} filename\n * @param {Date} expiration\n * @return {String}\n * @api public\n */\n\nClient.prototype.signedUrl = function(filename, expiration){\n  var epoch = Math.floor(expiration.getTime()/1000)\n    , pathname = url.parse(filename).pathname\n    , resource = '/' + this.bucket + ensureLeadingSlash(pathname);\n\n  var signature = auth.signQuery({\n      secret: this.secret\n    , date: epoch\n    , resource: resource\n  });\n\n  return this.url(ensureLeadingSlash(filename)) +\n    '?Expires=' + epoch +\n    '&AWSAccessKeyId=' + this.key +\n    '&Signature=' + encodeURIComponent(signature);\n};\n\n/**\n * Shortcut for `new Client()`.\n *\n * @param {Object} options\n * @see Client()\n * @api public\n */\n\nexports.createClient = function(options){\n  return new Client(options);\n};\n"]],"start1":0,"start2":0,"length1":0,"length2":16280}]],"length":16280}
